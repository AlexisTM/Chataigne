Scripts :

Dans tous les scripts :

 - script.log(***)				envoyer dans le logger

si une fonction update() est presente, alors elle sera executée régulièrement


Ajouter des parametres :

 - script.addBoolParameter(name,description, initialValue)		ajouter un parameter bool au script
 - script.addIntParameter(name,description, initialValue, minValue, maxValue)		ajouter un parameter int au script
 - script.addFloatParameter	(name,description, initialValue, minValue, maxValue)	ajouter un parameter float au script
 - script.addEnumParameter(name,description)		ajouter un parameter enum au script, pas encore fonctional car on ne peut pas rajouter d'options
  
> Exemple :

var monBoolParam = script.addBoolParameter("Mon nom","Ma description", false);  // ajoute un parametre qui est décoché par defaut

var monIntParam = script.addIntParameter("Mon nom","Ma description",5,0,100); // ajoute un int avec valeur par defaut à 5, qui peut aller de 0 à 100

var monFloatParam = script.addFloatParameter("Mon nom","Ma description",.3,0,1); // ajoute un int avec valeur par defaut à .5, qui peut aller de 0 à 1

var monEnumParam = script.addEnumParam("Mon nom","Ma description"); // ajoute un enum param
// pas encore fonctional car on ne peut pas rajouter d'options


Modifier et accéder à la valeur d'un paramètre :

var maValeur = monParam.get(); // pour récupérer la valeur
monParam.set(maValeur);  // pour modifier la valeur

Dans les cas des trigger :
monTrigger.trigger(); // pour déclencher le trigger

Fonctions utiles :
Des fonctions d'utilités sont accessibles via la variable "util"
 - util.getTime(); //retourne le temps en secondes (float)
 - util.atan2(x, y); //
 - util.toDegrees(radValue); // transforme de radians en degres
 - util.toRadians(degValue); // transforme de degres en radians
 
Accès global :
Tous les objets sont accessible via la variable "root"
On peut donc acceder à un module appelé "Mon Module OSC" via "root.modules.monModuleOSC"
Les différents accès possibles depuis le root sont :
 - root.modules		Acces aux modules
 - root.states		Acces aux states
 - root.sequences	Acces aux sequences
 - root.dashboards	Acces aux Dashboards
 - root.routers		Acces aux Routers

Les addresses de controle disponibles dans les tooltip peuvent aider à trouver l'acces à une variable
Dans certains cas, on veut pouvoir accéder à un enfant avec une string, il existe donc pour tous les parents une fonction monParent.getChild("monEnfant"); permettant de trouver un enfant par son nom



Fonctions locales :

Un script possède une variable "local" qui fait référence à l'objet qui contient ce script.
Par exemple, si un script est dans un module, local fera référence à ce module, si c'est un filtre, il fera référence à ce filtre.

Accès relatif :

Un objet est accessible à la fois en "absolu" (depuis root.*) et en relatif (depuis local.*)
On peut donc préferer accéder à une variable en relatif dans certains cas ou le script est amené à etre réutilisé à d'autres endroits.



Fonctions spéciales :

Chaque objet possède un ensemble de fonction spécifiques. Ces fonctions sont accessible depuis root.* ou local.*

 - Module OSC :
		>  send("/address",arg1,arg2,arg3); // envoyer un message osc via ce module, il peut y avoir 0 ou plusieurs arguments.

 - Module Serial :
		> send("mes donnees"); // envoi une string au device
		> sendLine("ma ligne"); //envoie une string puis '\n' au device
		> write(data); // envoi un paquet de données brutes (bytes) au device

 - Condition Script :
		> setValid(true | false) = valider / invalider cette condition
 

Suivant l'emplacement du script (dans un module, dans un filtre, dans une condition...), des fonctions spéciales peuvent également être appelées :

 - Dans un Module OSC :
		> oscEvent(address, args[]) {} //quand un message osc est recu par le module. les arguments s'accèdent via le tableau args[] (args[0], args[1],...)

- Dans un Module Serial :
		> serialEvent(maLigne); //Si le module est en mode LINE, recoit la ligne
		> serialEvent(bytes[]); //Si le module est dans un autre mode que LINE, recoit les bytes sous forme de tableau

- Dans un Mapping Filter:
		> filter(value) appelée à chaque changement de valeur du parametre de mapping, ou en permanence si "Continuous" est coché.
			La valeur retournée est la valeur de sortie du filtre


Managers :
Un Manager est un objet special qui contient une liste d'autres objets. Dans l'interface, ils sont repérable par la possibilité d'ajouter des enfants, comme les Modules, les States, les Sequences ou meme les Layers à l'intérieur d'une sequence.

Ces managers possèdent toutes les fonctionnalité d'un objet container, mais il est également possible d'accéder aux élements de ce manager via un tableau.
Par exemple, si je souhaite accéder au 3eme module de ma liste, je peux accéder via root.modules.items[2]; //l'index 0 est le 1er élement du tableau, donc le 1er module



//// CE QU'IL MANQUE
Ajouter des listeners sur les parametres
